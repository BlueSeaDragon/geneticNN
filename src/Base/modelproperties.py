import json
import os
from .modelskeleton import ModelSkeleton
from .modeltemplate import ModelTemplate
from typing import Iterable, Dict, Any
from sympy import symbols, Eq, solve, sympify
import copy

from torch.nn import Linear


# utility class to manage families of parameters generated by constraints
class Subsets:
    def __init__(self, elements: Iterable):
        self.data = {el: {el} for el in elements}
        self.reduced_list = {el for el in elements}
        self.inverse_reduced_list = {id(self.data[el]): el for el in self.reduced_list}

    def __getitem__(self, item):
        if item in self.data:
            return self.inverse_reduced_list[id(self.data[item])]
        else:
            raise KeyError(f'No key {item} found')

    def get_equivalence_class(self,item):
        if item in self.data:
            return self.data[item]
        else:
            raise KeyError(f'No key {item} found')

    def merge(self, el1, el2):
        if el1 in self.data and el2 in self.data:
            ref_1, ref_2 = self[el1], self[el2]

            union = self.data[ref_1].union(self.data[ref_2])
            id_class_ref1 = id(self.data[ref_1])
            id_class_ref2 = id(self.data[ref_2])
            for el in union:
                self.data[el] = union
            if ref_1 != ref_2:
                del self.inverse_reduced_list[id_class_ref2]
                self.reduced_list.discard(ref_2)
            self.inverse_reduced_list[id(union)] = ref_1
            if id(union) != id_class_ref1:
                del self.inverse_reduced_list[id_class_ref1]
        else:
            raise ValueError(f'One or both elements are not found: {el1} , {el2}')

    def check_add(self, el: object):
        if el not in self.data:
            self.data[el] = {el}
            self.reduced_list.add(el)

    def check_extend(self, elements: Iterable):
        for el in elements:
            self.check_add(el)



class ModelParameters:
    """
    Initialize ModelPropertiesMapper with the given parameters.

    :param model_skeleton: An instance of ModelSkeleton class.
    :param detailed_props: A boolean indicating whether to generate detailed properties.

    !! This class reads the properties of the submodels, inputs and outputs properties of the model_skeleton so make
    sure those are sufficiently completed before.!!
    Submodels properties need:
        - "source": the folder where the model file can be found (if the path is relative, will search from the parent
         folder of this file.
        - "name": the name of the model

    """
    def __init__(self, model_skeleton: ModelSkeleton):

        self.param_subset: Subsets = None
        self.model_skeleton = model_skeleton
        self.props: dict = None
        self.constraints: dict = {"equality": [], "symbolic": [], "parameter": {}}
        self.sympy_data: dict = {}
        self.variables_props = None

        self.model_skeleton.build_templates()

        self._find_all_parameters()
        self.generate_constraints()
        self.generate_global_parameters()
        self.solve_symbolic_constraints()

    # Solves the constraints on the model and generate the local and global dictionaries of parameters
    def _find_all_parameters(self):

        parameter_list = []
        for name, template in self.model_skeleton.submodels.items():
            template_parameters = template.parameters
            parameter_list.extend([(name, parameter_name) for parameter_name in template_parameters.keys()])

        self.param_subset = Subsets(parameter_list)



    def generate_constraints(self):

        runs = self.model_skeleton.runs
        for submodel_id, submodel in self.sub_props.items():
            for index, run in enumerate(runs):
                for var_name, data in run['inputs'].items():
                    input_run, input_var = data
                    if input_run > -1:
                        self.convert_run_linking_to_equality_constraint(((input_run,input_var),(index,var_name)))
            for constraint in submodel['constraints']:
                if constraint[0] == 'equality':
                    global_constraint = [self.get_extended_parameter_name(submodel_id, param) for param in constraint[1]]
                    self.add_an_equality_constraint(global_constraint)
                if constraint[0] == 'symbolic':
                    global_constraint = copy.copy(constraint[1])
                    global_constraint[0] = [self.get_extended_parameter_name(submodel_id, param) for param in global_constraint[0]]
                    self.add_a_symbolic_constraint(global_constraint)
                if constraint[0] == 'parameter':
                    global_constraint = (self.get_extended_parameter_name(submodel_id, constraint[1][0]), constraint[1][1])
                    self.add_a_parameter_constraint(global_constraint)
        # add inputs equality constraints
        inputs = self.model_skeleton.inputs
        for input_var in inputs:
            related_variables = self.model_skeleton.find_models_variables_connected_to_input(input_var)
            var_dim = self.variables_props[input_var]['dim']
            for k in range(var_dim):
                main_parameter = None
                for run_id, model_var in related_variables:
                    model = self.model_skeleton.runs[run_id]['id']
                    var_parameter = self.get_variable_parameter_name(model, model_var, k)
                    if main_parameter is None:
                        main_parameter = var_parameter
                    else:
                        global_constraint = [main_parameter, var_parameter]
                        self.add_an_equality_constraint(global_constraint)
        

    def generate_global_parameters(self):

        # generates list of global names for all parameters
        all_params = [self.get_extended_parameter_name(model_id, parameter_id) for model_id, model in self.sub_props.items() for
                      parameter_id in model['parameters'].keys()]
        self.param_subset = Subsets(all_params)
        for constraint in self.constraints['equality']:
            param_0 = constraint[0]
            for param in constraint[1:]:
                self.param_subset.merge(param_0, param)


        # rewrite symbolic constraints in terms of global variables only
        for constraint in self.constraints['symbolic']:
            for parameter in constraint[0]:
                parameter = self.param_subset[parameter]
        for param in self.constraints['parameter']:
            reference = self.param_subset[param]
            if reference is not param:
                self.constraints['parameter'][reference].extend(self.constraints['parameter'][param])
                del self.constraints['parameter'][param]

    def solve_symbolic_constraints(self):
        if len(self.constraints['symbolic']) > 0:
            global_parameters = self.param_subset.reduced_list
            sympy_variables = {param: symbols(param) for param in global_parameters}
            ineq = []
            eq = []

            # generate the formulae
            for constraint in self.constraints['symbolic']:
                params, formula = constraint
                for param_id, param in enumerate(params):
                    to_replace = f"${param_id} "
                    replacing = f"{param} "
                    new_formula = formula.replace(to_replace, replacing)
                    if ' = ' in new_formula:
                        e1, e2 = new_formula.split("=")
                        eq.append(Eq(sympify(e1), sympify(e2)))
                    if '<' in new_formula or '>' in new_formula:
                        ineq.append(sympify(new_formula))

            # find the constrained variables and their formulation
            constrained_params = set()
            for model_id, model in self.sub_props.items():
                for param, param_data in model['parameters'].items():
                    if 'constrained' in param_data and param_data['constrained'] is True:
                        constrained_params.add(self.param_subset[self.get_extended_parameter_name(model_id, param)])
            constrained_params_temp = {sympy_variables[param] for param in constrained_params}

            # replace the constrained variables by their formulation
            constrained_params_formulas: dict = {}
            while len(constrained_params_temp) > 0:
                variable_to_remove = None
                removing_expression = None
                for equation in eq:
                    if equation.lhs in constrained_params_temp:
                        variable_to_remove = equation.lhs
                        removing_expression = equation.rhs
                        break
                    if equation.rhs in constrained_params_temp:
                        variable_to_remove = equation.rhs
                        removing_expression = equation.lhs
                        break
                constrained_params_formulas[variable_to_remove] = removing_expression
                for i, equation in enumerate(eq):
                    eq[i] = equation.subs(variable_to_remove, removing_expression)

                for i, inequality in enumerate(ineq):
                    eq[i] = inequality.subs(variable_to_remove, removing_expression)

                constrained_params_temp.discard(variable_to_remove)

            # solve for the other unknowns
            solved_eq_dict = solve(eq)

            # find free variables
            free_vars = [var_name for var_name, var in sympy_variables.items() if var not in solved_eq_dict]
            self.sympy_data['free'] = free_vars
            # store constrained variables formula in sympy_data
            self.sympy_data['constrained'] = solved_eq_dict
            for param in constrained_params:
                self.sympy_data['constrained'][param] = constrained_params_formulas[sympy_variables[param]].subs(
                    solved_eq_dict)

    def add_a_symbolic_constraint(self, constraint):
        """
        :param constraint: A tuple that represents a linking constraint. It contains three elements:
                            - in_key: A tuple representing the input model property key.
                            - out_key: A tuple representing the output model property key.
                            - constraint_properties: A dictionary representing the properties of the constraint.

        :return: None

        This method adds a constraint linking two parameters in the graph of constraint
        """
        constraints = self.constraints.setdefault('symbolic', [])
        constraint.add(constraint)

    def add_an_equality_constraint(self, parameters_list: list):
        """
        :param parameters_list: A list of parameters that are deemed equals
        :return: None

        This method adds an equality constraint between al parameters in a list in the graph of constraint
        """
        constraints = self.constraints.setdefault('equality', [])
        constraints.append(parameters_list)

    def add_a_parameter_constraint(self, constraint):
        """
        :param constraint: A tuple representing the constraint to be added. The tuple should contain three elements: the model property to which the constraint applies, the parameter to which the constraint applies, and the properties of the constraint.
        :return: None

        The `add_a_parameter_constraint` method is used to add a constraint to a specific parameter of a model property in the ModelPropertiesMapper class. The constraint is represented as a tuple containing three elements:
        1. The model property to which the constraint applies.
        2. The parameter to which the constraint applies.
        3. The properties of the constraint.

        The method first retrieves the sub-properties of the given constraint by accessing the corresponding index in the `sub_props` list attribute of the ModelPropertiesMapper object. Then, it retrieves the `constraints` and `parameters` dictionaries from the `model_properties` dictionary of the sub-properties. After that, it adds the constraint to the `constraints` dictionary by setting the parameter as the key and a set of constraint properties as the value.

        Note that this method does not return anything. It modifies the `model_properties` dictionary directly.
        """
        (parameter, constraint_properties) = self.sub_props[constraint[0]], constraint[1], constraint[2]

        constraints = self.constraints
        constraints = constraints.setdefault('parameter', {})
        current_constraint = constraints.setdefault(parameter, [])
        current_constraint.append(constraint_properties)

    def get_variable_parameter_name(self, model_id, variable_id, dim):
        """free dimension not implemented yet
        if dim is -1:
            dim = "default"
        """
        return f"{model_id}___{variable_id}_{dim}"


    def get_extended_parameter_name(self, model_id: str, parameter_id: str):
        return f"{model_id}__{parameter_id}"

    def get_global_parameter(self,model_id: str, parameter_id: str):
        return self.param_subset[self.get_extended_parameter_name(model_id,parameter_id)]
    def get_local_parameter(self, parameter_id: str):
        model_id, local_parameter = parameter_id.split('__', 1)
        return model_id, local_parameter

    def check_and_generate_variables_parameters(self):
        """
        Iterates through submodel variables and generates corresponding parameters if they are missing.

        :return: None
        """
        for submodel_id, submodel in self.sub_props.items():
            for variable, var_data in submodel['variables'].items():
                var_dim = var_data['dim']
                '''free dimension not implemented yet
                if var_dim is -1:
                    #add a default parameter
                    param_name = self.get_variable_parameter_name(variable,-1)
                    if param_name not in submodel['params']:
                        # Generate the parameter corresponding to the dimension index of the variable
                        submodel['params'][param_name] = {'type': var_data['type']}
                else:
                '''
                for index in range(var_data['dim']):
                    param_name = f"_{variable}_{index}"

                    if param_name not in submodel['parameters']:
                        # Generate the parameter corresponding to the dimension index of the variable
                        submodel['parameters'][param_name] = {'type': 'int', 'virtual': True}

    def convert_run_linking_to_equality_constraint(self, constraint):
        """
        :param constraint: A tuple representing the constraint to be converted. The tuple should have two elements: the input constraint location and the output constraint location.
        :return: None

        This method is used to convert a constraint linking two variables to a constraint on the parameters of the variables. It takes in a constraint tuple, extract the necessary information from it, and performs the conversion. The converted constraint is then added as a linking constraint.

        The constraint tuple should be of the following format:
            - The input constraint location should be a tuple consisting of two elements: the submodel key and the variable key of the input constraint.
            - The output constraint location should be a tuple consisting of two elements: the submodel key and the variable key of the output constraint.

        The method first accesses the properties of the submodels stored in the `sub_props` attribute of the `ModelPropertiesMapper` instance. It retrieves the input and output variables based on the provided constraint locations.

        Next, the method checks the compatibility of the dimensions of the input and output variables. If they are not compatible, an `AssertionError` is raised with a descriptive error message.

        Finally, the method adds a parameter constraint for each dimension of the input variable. The parameter constraint is created using the submodel keys, the modified constraint locations with dimension indexes appended, and a boolean indicating that it is a parameter constraint. The created parameter constraint is then added as a linking constraint using the `add_a_linking_constraint` method.

        Example usage:
            mapper = ModelPropertiesMapper()
            constraint = (("submodel_key_1", "variable_key_1"), ("submodel_key_2", "variable_key_2"))
            mapper.convert_variable_to_parameter_constraint(constraint)
        """
        i_constraint_loc, o_constraint_loc = constraint
        input_run_id, variable_key_inp = i_constraint_loc
        output_run_id, variable_key_out = o_constraint_loc

        input_model_id = self.model_skeleton.runs[input_run_id]['id']
        output_model_id = self.model_skeleton.runs[output_run_id]['id']

        # Accessing properties of submodels
        subs = self.sub_props

        input_var = subs[input_model_id]['variables'][variable_key_inp]
        output_var = subs[output_model_id]['variables'][variable_key_out]

        # Checking compatibility of variables
        if input_var['dim'] is not output_var['dim']:
            raise AssertionError(
                f" Dimension of variables not matching for variable {i_constraint_loc}"
                f" (dim : {input_var['dim']}) and "
                f"variable {o_constraint_loc} (dim : {output_var['dim']})")

        # Adding parameter constraints
        for dim_index in range(input_var['dim']):
            input_param = self.get_variable_parameter_name(input_model_id, variable_key_inp, dim_index)
            output_param = self.get_variable_parameter_name(output_model_id, variable_key_out, dim_index)
            param_constraint = [input_param, output_param]
            self.add_an_equality_constraint(param_constraint)

    def resolve_a_parameter_linking_constraint_set(self, base_parameter):
        params_set = self.param_subset[base_parameter]
        constraints = [(param, constraint) for param in params_set for constraint in
                       self.constraints['linking']['up'][param]]
        down_constraints = [(param, constraint) for param in params_set for constraint in
                            self.constraints['linking']['up'][param]]
        constraints.extend(down_constraints)
        constraints = [constraint for constraint in constraints if constraint[1][1] is True]
        while (len(constraints) > 0):
            for param, constraint in constraints:
                param_1 = param
                param_2 = constraint[0]
                self.param_subset.merge(param_1, param_2)

    def get_defaults(self):
        """
        :return: A dictionary containing the default values for each parameter in each model
        """
        # set defaults for equivalent parameters with equality
        defaults_front = self.get_global_defaults()

        defaults_total = {model_id: {param: 0 for param in model['parameters'].keys()} for model_id, model in self.sub_props.items()}
        for param, value in defaults_front.items():
            for equ in self.param_subset.get_equivalence_class(param):
                model_id, local_param = self.get_local_parameter(equ)
                defaults_total[model_id][local_param] = defaults_front[param]

        return defaults_total

    def get_global_defaults(self):
        """
        Returns the default values for each global parameter in the model.

        :return: A dictionary mapping each parameter to its default value.
        """
        defaults_front = {item: 0 for item in self.param_subset.reduced_list}
        for param in defaults_front.keys():
            default_value = None
            virtual = True
            for equ in self.param_subset.get_equivalence_class(param):
                model_id, local_param = self.get_local_parameter(equ)
                default_value = self.sub_props[model_id]['parameters'][local_param].setdefault('default', None)
                virtual_value = self.sub_props[model_id]['parameters'][local_param].setdefault('virtul', False)
                virtual = virtual and virtual_value
                if default_value is not None:
                    defaults_front[param] = default_value
                    continue
            if virtual:
                del defaults_front[param]

        return defaults_front

    def get_all_globals(self):
        """
        Returns the global parameters of the model.

        :return: A set of parameters names as strings.
        """
        return self.param_subset.reduced_list

    def check_global_virtual(self,parameter) -> bool:
        model, local_name = self.get_local_parameter(parameter)
        parameter_props = self.sub_props[model]["parameters"][local_name]
        virtual = parameter_props.get('virtual', False)
        for other_param in self.param_subset.get_equivalence_class(parameter):
            other_model, other_param_local = self.get_local_parameter(other_param)
            virtual = virtual and self.sub_props[other_model]["parameters"][other_param_local].get('virtual', False)
            if not virtual:
                #parameters[parameter]['virtual'] = False
                return False
        return True


    def get_high_order_props(self):
        # variables info
        props = {"variables": self.variables_props}

        # parameters info
        parameters = {}
        parameters_defaults = self.get_global_defaults()
        for parameter, default_value in parameters_defaults.items():
            model, local_name = self.get_local_parameter(parameter)
            parameters[parameter] = self.sub_props[model]["parameters"][local_name].copy()
            parameters[parameter]["default"] = default_value
            parameters[parameter]['virtual'] = self.check_global_virtual(parameter)


        props["parameters"] = parameters

        constraints = []

        # equality constraints
        for input_var,input_data in self.variables_props.items():
            if input_data["io"] == "out":
                continue
            related_variables = self.model_skeleton.find_models_variables_connected_to_input(input_var)
            run_id,model_var = related_variables[0]
            model = self.model_skeleton.runs[run_id]['id']
            var_dim = input_data["dim"]
            for k in range(var_dim):
                var_param = self.param_subset[self.get_variable_parameter_name(model, model_var,k)]
                constraints.append(["equality", [f"_{input_var}_{k}",var_param]])
        outputs = self.model_skeleton.outputs
        for output_var, output_info in outputs.items():
            output_model = self.model_skeleton.runs[output_info[0]]["id"]
            output_var_name = output_info[1]
            output_data = self.variables_props[output_var]
            var_dim = output_data["dim"]
            for k in range(var_dim):
                var_param = self.param_subset[self.get_variable_parameter_name(output_model, output_var_name,k)]
                constraints.append(["equality", [f"_{output_var}_{k}", var_param]])

        for constraint in self.constraints["symbolic"]:
            constraints.append(["symbolic", constraint])

        for constraint in self.constraints["parameter"]:
            constraints.append(["parameter", constraint])

        props["constraints"] = constraints.copy()

        return props
